#!/usr/bin/env python
# coding: utf-8
#
# Copyright (c) 2009, Paul TÃ¶tterman <paul.totterman@iki.fi>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''Generate bind9 zone file from ldap.'''

import ldap
import optparse
import re
import time

LDAP_CONF = '/etc/ldap/ldap.conf'
NS_RE = re.compile('ns\d+')
RECORD = '%(name)s\t%(ttl)s\t%(class)s\t%(type)s\t%(data)s'
RECORDS = {'nSRecord':    'NS',
           'mXRecord':    'MX',
           'aRecord':     'A',
           'cNAMERecord': 'CNAME'}

def get_ldap_base(persist={}):
    '''Get LDAP base from ldap.conf(5)'''
    # pylint: disable=W0141,W0102
    if 'base' in persist:
        return persist['base']

    ldap_conf = open(LDAP_CONF, 'rb')
    pattern = re.compile(r'''^\s*[bB][aA][sS][eE]\s+(.+)\s*$''')
    matches = [ pattern.search(x) for x in ldap_conf.readlines() ]
    base = filter(None, matches)[0].group(1)

    persist['base'] = base
    return base

def output_header(zone, ttl):
    '''Output zonefile header.'''
    print '; autogenerated bind zone file by ldap2zone.py'
    print '; vim: set filetype=bindzone:'
    print '$ORIGIN %s.' % zone
    print '$TTL\t%s' % ttl

def output_record(values):
    '''Output a single DNS record.'''
    default_values = {'ttl': '', 'class': 'IN'}
    out_values = default_values.copy()
    out_values.update(values)
    print RECORD % out_values

def mtime2epoch(mtimestr):
    '''Convert LDAP modifyTimestamp attribute value to unix epoch timestamp.'''
    return int(time.mktime(time.strptime(mtimestr, "%Y%m%d%H%M%SZ")))

def dn2name(base, zone, dn):
    '''Convert LDAP dn to zone file record name.'''
    # pylint: disable=C0103
    zonedn = ','.join(['dc=%s' % x for x in zone.split('.')])
    rdn = dn.rsplit(zonedn + ',' + base)[0].rstrip(',')
    if rdn == '':
        return '@'
    rdn = [c.split('=') for c in rdn.split(',')]
    name = '.'.join([v for k, v in rdn if k == 'dc'])
    return name

def generate_zonefile(ds, base, zone):
    '''Generates the zonefile from ldap. Does the actual work.'''
    # pylint: disable=C0103
    filterstr = '(&(objectClass=dNSDomain)(associatedDomain=%s))' % zone
    attrs = ['dc', 'modifyTimestamp', 'sOARecord'] + RECORDS.keys()
    entries = ds.search_s(base, ldap.SCOPE_SUBTREE, filterstr, attrs)

    output_header(zone, 60)

    soas = [e[1]['sOARecord'][0] for e in entries if 'sOARecord' in e[1]]

    if len(soas) == 1:
        output_record({'name': '@',
                       'type': 'SOA',
                       'data': soas[0]})
    else:
        epochs = [mtime2epoch(e[1]['modifyTimestamp'][0]) for e in entries]
        serial = max(epochs)

        output_record({'name': '@',
                       'type': 'SOA',
                       'data': ('ns1.%(zone)s. hostmaster.%(zone)s. (%(serial)s'
                                ' 1200 180 1209600 60)' % {'serial': serial,
                                                           'zone': zone})})

    for entry in entries:
        name = dn2name(base, zone, entry[0])
        attrs = entry[1]
        for record in RECORDS.keys():
            if record in attrs:
                for value in attrs[record]:
                    output_record({'name': name,
                                   'type': RECORDS[record],
                                   'data': value})

def run():
    '''The main function'''
    parser = optparse.OptionParser()
    parser.add_option('-D',
                      '--binddn',
                      action='store',
                      dest='binddn',
                      help='LDAP bind DN')
    parser.add_option('-w',
                      '--bindpw',
                      action='store',
                      dest='bindpw',
                      help='LDAP bind password')
    parser.add_option('-H',
                      '--uri',
                      action='store',
                      dest='uri',
                      help='LDAP URI')
    parser.add_option('-b',
                      '--base',
                      action='store',
                      dest='base',
                      help='LDAP search base')
    parser.add_option('-z',
                      '--zone',
                      action='store',
                      dest='zone',
                      help='Name of the zone')

    try:
        import optcomplete
        optcomplete.autocomplete(parser)
    except ImportError:
        pass

    (opts, _) = parser.parse_args()

    uri = ldap.get_option(ldap.OPT_URI)
    if opts.uri:
        uri = opts.uri

    base = 'ou=DNS,%s' % get_ldap_base()
    if opts.base:
        base = opts.base

    # pylint: disable=C0103
    dn = [rdn.split('=') for rdn in base.split(',')]
    dcs = [v for k, v in dn if k == 'dc']
    zone = '.'.join(dcs)

    if opts.zone:
        zone = opts.zone

    ds = ldap.initialize(uri)

    if opts.binddn:
        ds.simple_bind_s(opts.binddn, opts.bindpw)

    generate_zonefile(ds, base, zone)

if __name__ == '__main__':
    run()
