#!/usr/bin/env python
# coding: utf-8
#
# Copyright (c) 2009, Paul TÃ¶tterman <paul.totterman@iki.fi>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''Generate bind9 zone file from ldap.'''

import ldap
import optparse
import re
import time

LDAP_CONF = '/etc/ldap/ldap.conf'
NS_RE = re.compile('ns\d+')
RECORD = '%(name)s\t%(ttl)s\t%(type)s\t%(data)s'
RECORD_ATTRIBUTES = ['a6Record',
                     'aAAARecord',
                     'aFSDBRecord',
                     'aPLRecord',
                     'aRecord',
                     'cERTRecord',
                     'cNAMERecord',
                     'dHCIDRecord',
                     'dLVRecord',
                     'dNAMERecord',
                     'dNSKEYRecord',
                     'dSRecord',
                     'hINFORecord',
                     'hIPRecord',
                     'iPSECKEYRecord',
                     'kEYRecord',
                     'kXRecord',
                     'lOCRecord',
                     'mDRecord',
                     'mINFORecord',
                     'mXRecord',
                     'nAPTRRecord',
                     'nSEC3PARAMRecord',
                     'nSEC3Record',
                     'nSECRecord',
                     'nSRecord',
                     'nXTRecord',
                     'pTRRecord',
                     'rPRecord',
                     'rRSIGRecord',
                     'sIGRecord',
                     #'sOARecord', # special case
                     'sPFRecord',
                     'sRVRecord',
                     'sSHFPRecord',
                     'tARecord',
                     'tKEYRecord',
                     'tSIGRecord',
                     'tXTRecord']
SOA_ATTRIBUTES = {'sOANameServer': 'ns',
                  'sOAEmail':      'email',
                  'sOASerial':     'serial',
                  'sOARefresh':    'refresh',
                  'sOARetry':      'retry',
                  'sOAExpire':     'expire',
                  'sOANegCache':   'negcache'}
SOA_DEFAULTS = {'refresh':  1200, # RFC1912
                'retry':    180,
                'expire':   1209600, # RFC1912
                'negcache': 60}

def get_ldap_base(persist={}):
    '''Get LDAP base from ldap.conf(5)'''
    # pylint: disable=W0141,W0102
    if 'base' in persist:
        return persist['base']

    ldap_conf = open(LDAP_CONF, 'rb')
    pattern = re.compile(r'''^\s*[bB][aA][sS][eE]\s+(.+)\s*$''')
    matches = [ pattern.search(x) for x in ldap_conf.readlines() ]
    base = filter(None, matches)[0].group(1)

    persist['base'] = base
    return base

def output_header(zone, ttl):
    '''Output zonefile header.'''
    print '; autogenerated bind zone file by ldap2zone.py'
    print '; vim: set filetype=bindzone:'
    print '$ORIGIN %s.' % zone
    print '$TTL\t%s' % ttl

def output_record(values):
    '''Output a single DNS record.'''
    print RECORD % values

def mtime2epoch(mtimestr):
    '''Convert LDAP modifyTimestamp attribute value to unix epoch timestamp.'''
    return int(time.mktime(time.strptime(mtimestr, "%Y%m%d%H%M%SZ")))

def attribute2type(attribute):
    '''Convert LDAP attribute name to DNS record type.'''
    return attribute.split('Record')[0].upper()

def output_soa(entries, zone_entry):
    '''Output SOA record based on existing values in zone entry or guesses.'''
    if 'sOARecord' in zone_entry[1]:
        output_record({'name': zone_entry[1]['relativeDomainName'][0],
                       'type': attribute2type('sOARecord'),
                       'data': zone_entry[1]['sOARecord'][0]})
    else:
        soa_values = SOA_DEFAULTS.copy()
        for attr in SOA_ATTRIBUTES.keys():
            if attr in zone_entry[1]:
                soa_values[SOA_ATTRIBUTES[attr]] = zone_entry[1][attr][0]

        if not 'serial' in soa_values:
            epochs = [mtime2epoch(e[1]['modifyTimestamp'][0]) for e in entries]
            soa_values['serial'] = max(epochs)

        output_record({'name': '@',
                       'ttl':  '',
                       'type': 'SOA',
                       'data': ('%(ns)s %(email)s (%(serial)s %(refresh)s '
                                '%(retry)s %(expire)s %(negcache)s)' %
                                soa_values)})

def generate_zonefile(ds, base, zone):
    '''Generates the zonefile from ldap. Does the actual work.'''
    # pylint: disable=C0103
    filterstr = '(&(objectClass=dNSRecord)(zoneName=%s))' % zone
    attrs = ['relativeDomainName', 'modifyTimestamp', 'sOARecord',
             'sOANameServer', 'sOAEmail', 'sOASerial', 'sOARetry',
             'sOAExpire', 'sOANegCache', 'defaultTTL', 'dNSView',
             'dNSTTL'] + RECORD_ATTRIBUTES
    entries = ds.search_s(base, ldap.SCOPE_SUBTREE, filterstr, attrs)

    zone_entry = [e for e in entries if e[1]['relativeDomainName'][0] == '@'][0]

    default_ttl = 60
    if 'defaultTTL' in zone_entry[1]:
        default_ttl = zone_entry[1]['defaultTTL'][0]

    output_header(zone, default_ttl)

    output_soa(entries, zone_entry)

    for entry in entries:
        attrs = entry[1]
        name = attrs['relativeDomainName'][0]
        ttl = ''
        if 'dNSTTL' in attrs and attrs['dNSTTL'][0] != default_ttl:
            ttl = attrs['dNSTTL'][0]
        for attr in RECORD_ATTRIBUTES:
            if attr in attrs:
                for value in attrs[attr]:
                    output_record({'name': name,
                                   'ttl':  ttl,
                                   'type': attribute2type(attr),
                                   'data': value})

def run():
    '''The main function'''
    parser = optparse.OptionParser()
    parser.add_option('-D',
                      '--binddn',
                      action='store',
                      dest='binddn',
                      help='LDAP bind DN')
    parser.add_option('-w',
                      '--bindpw',
                      action='store',
                      dest='bindpw',
                      help='LDAP bind password')
    parser.add_option('-H',
                      '--uri',
                      action='store',
                      dest='uri',
                      help='LDAP URI')
    parser.add_option('-b',
                      '--base',
                      action='store',
                      dest='base',
                      help='LDAP search base')
    parser.add_option('-z',
                      '--zone',
                      action='store',
                      dest='zone',
                      help='Name of the zone')

    try:
        import optcomplete
        optcomplete.autocomplete(parser)
    except ImportError:
        pass

    (opts, _) = parser.parse_args()

    uri = ldap.get_option(ldap.OPT_URI)
    if opts.uri:
        uri = opts.uri

    base = 'ou=Hosts,%s' % get_ldap_base()
    if opts.base:
        base = opts.base

    # pylint: disable=C0103
    dn = [rdn.split('=') for rdn in base.split(',')]
    dcs = [v for k, v in dn if k == 'dc']
    zone = '.'.join(dcs)

    if opts.zone:
        zone = opts.zone

    ds = ldap.initialize(uri)

    if opts.binddn:
        ds.simple_bind_s(opts.binddn, opts.bindpw)

    generate_zonefile(ds, base, zone)

if __name__ == '__main__':
    run()
